{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 215, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/genkit.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/googleai';\n\nexport const ai = genkit({\n  plugins: [googleAI()],\n  model: 'googleai/gemini-2.0-flash',\n});\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AAAA;;;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;QAAC,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD;KAAI;IACrB,OAAO;AACT","debugId":null}},
    {"offset": {"line": 252, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/extract-data-from-pdf.ts"],"sourcesContent":["'use server';\n/**\n * @fileOverview Extracts data from a PDF using OCR and AI.\n *\n * - extractDataFromPdf - A function that handles the data extraction process.\n * - ExtractDataFromPdfInput - The input type for the extractDataFromPdf function.\n * - ExtractDataFromPdfOutput - The return type for the extractDataFromPdf function.\n */\n\nimport { ai } from '@/ai/genkit';\nimport { createWorker } from 'tesseract.js';\nimport {z} from 'genkit';\n\nconst ExtractDataFromPdfInputSchema = z.object({\n  pdfDataUri: z\n    .string()\n    .describe(\n      \"The PDF document, as a data URI that must include a MIME type and use Base64 encoding. Expected format: 'data:<mimetype>;base64,<encoded_data>'.\"\n    ),\n});\nexport type ExtractDataFromPdfInput = z.infer<typeof ExtractDataFromPdfInputSchema>;\n\nconst ExtractDataFromPdfOutputSchema = z.object({\n  extractedData: z.record(z.string(), z.any()).describe('The extracted data from the PDF, as a JSON object.'),\n});\nexport type ExtractDataFromPdfOutput = z.infer<typeof ExtractDataFromPdfOutputSchema>;\n\nexport async function extractDataFromPdf(input: ExtractDataFromPdfInput): Promise<ExtractDataFromPdfOutput> {\n  return extractDataFromPdfFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'extractDataFromPdfPrompt',\n  input: { schema: ExtractDataFromPdfInputSchema },\n  prompt: `You are an expert data extraction specialist. You will be provided with raw text extracted from a PDF document using OCR. Your task is to read the provided text and list the relevant data points you find, corresponding to the following categories: classe, cours, date, nom_du_professeur, nombre_des_présents, présences (listing each entry with number and name), salle_n, and séance.\n\nPresent this list in a clear and easily parseable format, for example, a simple list of key: value pairs or a similar structure that clearly delineates each data point and its corresponding value. Do not output in JSON format.\n\nRaw text from PDF:\n{{text}}\n\nInput:\nDate: 17/01/2025\nClasse: Mastére ingénierie des systémes de décision Cours: Gestion de production\nSéance de : 10h30 a 12h30 Salle n° :  TDSB Signature :\nNom du professeur :                                                Nombre des présents : 12\nNom & Prénom Signature\n1 Sihem Arfa Saty,\n2 Raja Babi 29. Word\n3 Adam Ben Jeddi Ada\n4 Amina Ben Ahmed Amy\n5 Lina Rmili\n6 Chayma Benab ¢ f\n7 anas Meziane anas\n8 Mohamed Hadhi @\n9 Saif islam hajbrahim yslon\n10 Jelen Louaghi ghy\n11 Maram Dhifrom Me\n12 Ohethouen Noor Cletht\n\nOutput:\nclasse: Mastére ingénierie des systémes de décision\ncours: Gestion de production\ndate: 17/01/2025\nnom_du_professeur:\nnombre_des_présents: 12\nprésences:\n- n: 1, nom_prénom: Sihem Arfa\n- n: 2, nom_prénom: Raja Babi\n- n: 3, nom_prénom: Adam Ben Jeddi\n- n: 4, nom_prénom: Amina Ben Ahmed\n- n: 5, nom_prénom: Lina Rmili\n- n: 6, nom_prénom: Chayma Benab\n- n: 7, nom_prénom: anas Meziane\n- n: 8, nom_prénom: Mohamed Hadhi\n- n: 9, nom_prénom: Saif islam hajbrahim\n- n: 10, nom_prénom: Jelen Louaghi\n- n: 11, nom_prénom: Maram Dhifrom\n- n: 12, nom_prénom: Ohethouen Noor\nsalle_n: TDSB\nséance: 10h30 a 12h30`,\n});\n\nconst extractDataFromPdfFlow = ai.defineFlow(\n  {\n    name: 'extractDataFromPdfFlow',\n    inputSchema: ExtractDataFromPdfInputSchema,\n    outputSchema: ExtractDataFromPdfOutputSchema,\n  },\n  async (input) => {\n    const worker = await createWorker({\n      // Attempt to set the worker path explicitly\n      workerPath: '../node_modules/tesseract.js/dist/worker.min.js',\n    });\n    await worker.loadLanguage('eng+fra'); // Load English and French languages for OCR\n    await worker.initialize('eng+fra');\n\n    const { data: { text: ocrText } } = await worker.recognize(input.pdfDataUri);\n\n    await worker.terminate();\n\n    // Now, pass the OCR text to the AI model for initial data identification\n    const { output } = await prompt({ text: ocrText });\n    console.log('Raw model output (list format):', output);\n\n    let extractedData: any = {};\n    try {\n      // Parse the model's output (which should be a list of key: value pairs)\n      const lines = (output as string).split('\\n').filter(line => line.trim() !== '');\n      let currentKey: string | null = null;\n      let presenceEntries: { n: number | null; nom_prénom: string | null }[] = [];\n\n      for (const line of lines) {\n        if (line.startsWith('- n:')) {\n          // Handling presence entries\n          const presenceMatch = line.match(/- n: (\\d+), nom_prénom: (.*)/);\n          if (presenceMatch) {\n            presenceEntries.push({\n              n: parseInt(presenceMatch[1], 10),\n              nom_prénom: presenceMatch[2].trim(),\n            });\n          }\n        } else {\n          // Handling other key: value pairs\n          const parts = line.split(':');\n          if (parts.length >= 2) {\n            currentKey = parts[0].trim();\n            const value = parts.slice(1).join(':').trim();\n            if (currentKey === 'nombre_des_présents') {\n              extractedData[currentKey] = parseInt(value, 10) || null;\n            } else {\n              extractedData[currentKey] = value === '' ? null : value;\n            }\n          }\n        }\n      }\n\n      if (presenceEntries.length > 0) {\n        extractedData['présences'] = presenceEntries;\n      }\n\n      console.log('Constructed JSON data:', extractedData);\n    } catch (e) {\n      console.error('Failed to parse JSON from model output:', output, e);\n    }\n    return { extractedData: extractedData || {} }; // Return an empty object if parsing fails\n  }\n);\n"],"names":[],"mappings":";;;;;AACA;;;;;;CAMC,GAED;AACA;AACA;AAAA;;;;;;;AAEA,MAAM,gCAAgC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC7C,YAAY,uIAAA,CAAA,IAAC,CACV,MAAM,GACN,QAAQ,CACP;AAEN;AAGA,MAAM,iCAAiC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC9C,eAAe,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC,uIAAA,CAAA,IAAC,CAAC,MAAM,IAAI,uIAAA,CAAA,IAAC,CAAC,GAAG,IAAI,QAAQ,CAAC;AACxD;AAGO,eAAe,uCAAgB,GAAhB,mBAAmB,KAA8B;IACrE,OAAO,uBAAuB;AAChC;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAE,QAAQ;IAA8B;IAC/C,QAAQ,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qBA8CU,CAAC;AACtB;AAEA,MAAM,yBAAyB,mHAAA,CAAA,KAAE,CAAC,UAAU,CAC1C;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAO;IACL,MAAM,SAAS,MAAM,CAAA,GAAA,+IAAA,CAAA,eAAY,AAAD,EAAE;QAChC,4CAA4C;QAC5C,YAAY;IACd;IACA,MAAM,OAAO,YAAY,CAAC,YAAY,4CAA4C;IAClF,MAAM,OAAO,UAAU,CAAC;IAExB,MAAM,EAAE,MAAM,EAAE,MAAM,OAAO,EAAE,EAAE,GAAG,MAAM,OAAO,SAAS,CAAC,MAAM,UAAU;IAE3E,MAAM,OAAO,SAAS;IAEtB,yEAAyE;IACzE,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,OAAO;QAAE,MAAM;IAAQ;IAChD,QAAQ,GAAG,CAAC,mCAAmC;IAE/C,IAAI,gBAAqB,CAAC;IAC1B,IAAI;QACF,wEAAwE;QACxE,MAAM,QAAQ,AAAC,OAAkB,KAAK,CAAC,MAAM,MAAM,CAAC,CAAA,OAAQ,KAAK,IAAI,OAAO;QAC5E,IAAI,aAA4B;QAChC,IAAI,kBAAqE,EAAE;QAE3E,KAAK,MAAM,QAAQ,MAAO;YACxB,IAAI,KAAK,UAAU,CAAC,SAAS;gBAC3B,4BAA4B;gBAC5B,MAAM,gBAAgB,KAAK,KAAK,CAAC;gBACjC,IAAI,eAAe;oBACjB,gBAAgB,IAAI,CAAC;wBACnB,GAAG,SAAS,aAAa,CAAC,EAAE,EAAE;wBAC9B,YAAY,aAAa,CAAC,EAAE,CAAC,IAAI;oBACnC;gBACF;YACF,OAAO;gBACL,kCAAkC;gBAClC,MAAM,QAAQ,KAAK,KAAK,CAAC;gBACzB,IAAI,MAAM,MAAM,IAAI,GAAG;oBACrB,aAAa,KAAK,CAAC,EAAE,CAAC,IAAI;oBAC1B,MAAM,QAAQ,MAAM,KAAK,CAAC,GAAG,IAAI,CAAC,KAAK,IAAI;oBAC3C,IAAI,eAAe,uBAAuB;wBACxC,aAAa,CAAC,WAAW,GAAG,SAAS,OAAO,OAAO;oBACrD,OAAO;wBACL,aAAa,CAAC,WAAW,GAAG,UAAU,KAAK,OAAO;oBACpD;gBACF;YACF;QACF;QAEA,IAAI,gBAAgB,MAAM,GAAG,GAAG;YAC9B,aAAa,CAAC,YAAY,GAAG;QAC/B;QAEA,QAAQ,GAAG,CAAC,0BAA0B;IACxC,EAAE,OAAO,GAAG;QACV,QAAQ,KAAK,CAAC,2CAA2C,QAAQ;IACnE;IACA,OAAO;QAAE,eAAe,iBAAiB,CAAC;IAAE,GAAG,0CAA0C;AAC3F;;;IAvHoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 405, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 456, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAoR,GACjT,kDACA","debugId":null}},
    {"offset": {"line": 470, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAgQ,GAC7R,8BACA","debugId":null}},
    {"offset": {"line": 484, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}