{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 215, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/genkit.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/googleai';\n\nexport const ai = genkit({\n  plugins: [googleAI()],\n  model: 'googleai/gemini-2.0-flash',\n});\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AAAA;;;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;QAAC,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD;KAAI;IACrB,OAAO;AACT","debugId":null}},
    {"offset": {"line": 292, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/schemas/pdf-data-schema.ts"],"sourcesContent":["\nimport { z } from 'zod';\n\n// Schema for the actual structured data the AI should extract\nexport const ExtractedPdfDataSchema = z.object({\n  classe: z.string().describe('The class name. Return \"\" if not found.'),\n  cours: z.string().describe('The course name. Return \"\" if not found.'),\n  date: z.string().describe('The date of the session. Return \"\" if not found.'),\n  nom_du_professeur: z.string().describe(\"The professor's name. Return \\\"\\\" if not found.\"),\n  nombre_des_présents: z.number().describe('The number of present students. Return 0 if not found.'),\n  salle_n: z.string().describe('The room number. Return \"\" if not found.'),\n  séance: z.string().describe('The session information. Return \"\" if not found.'),\n  présences: z.array(z.object({\n    n: z.string().describe('The student number or ID. Return \"\" if not found.'),\n    nom_prénom: z.string().describe(\"The student's full name. Return \\\"\\\" if not found.\"),\n  })).describe('An array representing the attendees. Return [] if not found or if data is missing for all attendees.'),\n});\nexport type ExtractedPdfData = z.infer<typeof ExtractedPdfDataSchema>;\n"],"names":[],"mappings":";;;AACA;;AAGO,MAAM,yBAAyB,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC7C,QAAQ,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC5B,OAAO,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC3B,MAAM,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC1B,mBAAmB,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACvC,qBAAqB,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACzC,SAAS,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC7B,QAAQ,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC5B,WAAW,oIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QAC1B,GAAG,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;QACvB,YAAY,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAClC,IAAI,QAAQ,CAAC;AACf","debugId":null}},
    {"offset": {"line": 316, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/extract-data-from-pdf.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview Extracts data from a PDF using AI (Genkit), with an option for Google Cloud Vision OCR.\n *\n * - extractDataFromPdf - A function that handles the data extraction process.\n * - ExtractDataFromPdfInput - The input type for the extractDataFromPdf function.\n * - ExtractDataFromPdfOutput - The return type for the extractDataFromPdf function.\n */\n\nimport { ai } from '@/ai/genkit';\nimport { z } from 'genkit';\nimport { ImageAnnotatorClient } from '@google-cloud/vision';\nimport type { ExtractedPdfData } from '@/ai/schemas/pdf-data-schema'; \nimport { ExtractedPdfDataSchema } from '@/ai/schemas/pdf-data-schema'; \n\n// Schema for the overall flow input\nconst ExtractDataFromPdfInputSchema = z.object({\n  pdfDataUri: z.string().describe(\n    \"The PDF document, as a data URI that must include a MIME type and use Base64 encoding. Expected format: 'data:<mimetype>;base64,<encoded_data>'.\"\n  ),\n  extractionEngine: z.enum(['genkitDirect', 'googleCloudVision'])\n    .default('genkitDirect')\n    .describe('The engine to use for PDF data extraction.'),\n});\nexport type ExtractDataFromPdfInput = z.infer<typeof ExtractDataFromPdfInputSchema>;\n\n// Schema for the flow's final output to the frontend\nconst ExtractDataFromPdfOutputSchema = z.object({\n  jsonOutput: z.string().describe('The extracted data from the PDF, as a JSON string.'),\n  error: z.string().optional().describe('An error message if extraction failed.'),\n});\nexport type ExtractDataFromPdfOutput = z.infer<typeof ExtractDataFromPdfOutputSchema>;\n\nexport async function extractDataFromPdf(input: ExtractDataFromPdfInput): Promise<ExtractDataFromPdfOutput> {\n  return extractDataFromPdfFlow(input);\n}\n\n// Prompt for direct PDF processing by Genkit AI\nconst genkitDirectPdfProcessPrompt = ai.definePrompt({\n  name: 'genkitDirectPdfProcessPrompt',\n  input: { schema: z.object({ pdfDataUri: ExtractDataFromPdfInputSchema.shape.pdfDataUri }) },\n  output: { schema: ExtractedPdfDataSchema },\n  prompt: `You are an expert data extraction specialist.\nYou will receive a PDF document. Your task is to analyze this document and extract all the relevant information from it.\nReturn the extracted data as a JSON object strictly conforming to the provided schema.\n\nCRITICAL INSTRUCTION FOR HANDLING MISSING DATA:\n- For all string fields (e.g., \\`classe\\`, \\`cours\\`, \\`date\\`, \\`nom_du_professeur\\`, \\`salle_n\\`, \\`séance\\`, and within \\`présences\\`: \\`n\\`, \\`nom_prénom\\`), if the information cannot be found or determined from the PDF, you MUST use an empty string \\`\"\"\\` as its value for that field.\n- For the \\`nombre_des_présents\\` field (a number), if it cannot be determined, you MUST use the number \\`0\\` as its value.\n- For the \\`présences\\` array, if no attendees are found or the data is missing for all attendees, you MUST use an empty array \\`[]\\` as its value. If some attendees are found but some details are missing for an individual attendee, apply the empty string rule for their \\`n\\` or \\`nom_prénom\\` fields.\n- DO NOT OMIT ANY KEYS specified in the schema. The goal is to always return a JSON object that strictly conforms to the defined structure, using these empty/default values for missing information.\n\nPDF Document:\n{{media url=pdfDataUri}}`,\n});\n\n// Prompt for structuring text extracted by an external OCR (like Google Cloud Vision)\nconst structureOcrTextPrompt = ai.definePrompt({\n  name: 'structureOcrTextPrompt',\n  input: { schema: z.object({ ocrText: z.string().describe(\"Text extracted from a document by an OCR engine.\") }) },\n  output: { schema: ExtractedPdfDataSchema },\n  prompt: `You are an expert data extraction specialist.\nYou will receive text that has been extracted from a document using an OCR engine. Your task is to analyze this text and extract all the relevant information from it.\nReturn the extracted data as a JSON object strictly conforming to the provided schema.\n\nCRITICAL INSTRUCTION FOR HANDLING MISSING DATA:\n- For all string fields (e.g., \\`classe\\`, \\`cours\\`, \\`date\\`, \\`nom_du_professeur\\`, \\`salle_n\\`, \\`séance\\`, and within \\`présences\\`: \\`n\\`, \\`nom_prénom\\`), if the information cannot be found or determined from the text, you MUST use an empty string \\`\"\"\\` as its value for that field.\n- For the \\`nombre_des_présents\\` field (a number), if it cannot be determined, you MUST use the number \\`0\\` as its value.\n- For the \\`présences\\` array, if no attendees are found or the data is missing for all attendees, you MUST use an empty array \\`[]\\` as its value. If some attendees are found but some details are missing for an individual attendee, apply the empty string rule for their \\`n\\` or \\`nom_prénom\\` fields.\n- DO NOT OMIT ANY KEYS specified in the schema. The goal is to always return a JSON object that strictly conforms to the defined structure, using these empty/default values for missing information.\n\nOCR'd Text:\n{{{ocrText}}}`,\n});\n\n\nconst extractDataFromPdfFlow = ai.defineFlow(\n  {\n    name: 'extractDataFromPdfFlow',\n    inputSchema: ExtractDataFromPdfInputSchema,\n    outputSchema: ExtractDataFromPdfOutputSchema, \n  },\n  async (flowInput) => {\n    console.log(`Starting PDF data extraction with engine: ${flowInput.extractionEngine}`);\n\n    const defaultEmptyStructuredData: ExtractedPdfData = {\n      classe: \"\", cours: \"\", date: \"\", nom_du_professeur: \"\",\n      nombre_des_présents: 0, salle_n: \"\", séance: \"\", présences: [],\n    };\n    const defaultEmptyJsonOutputString = JSON.stringify(defaultEmptyStructuredData);\n\n    try {\n      let structuredData: ExtractedPdfData | null = null;\n\n      if (flowInput.extractionEngine === 'googleCloudVision') {\n        console.log('Using Google Cloud Vision OCR engine.');\n        const serviceAccountCredsJsonString = process.env.GOOGLE_SERVICE_ACCOUNT_CREDENTIALS_JSON;\n        if (!serviceAccountCredsJsonString) {\n          return { jsonOutput: defaultEmptyJsonOutputString, error: 'Google Service Account credentials are not configured for Vision API.' };\n        }\n\n        let visionCredentials;\n        try {\n          visionCredentials = JSON.parse(serviceAccountCredsJsonString);\n           if (visionCredentials && visionCredentials.private_key) {\n             visionCredentials.private_key = visionCredentials.private_key.replace(/\\\\n/g, '\\n');\n           }\n        } catch (e: any) {\n          console.error('Failed to parse Google Service Account credentials for Vision API:', e.message);\n          return { jsonOutput: defaultEmptyJsonOutputString, error: `Invalid Google Service Account credentials format for Vision API: ${e.message}` };\n        }\n        \n        const visionClient = new ImageAnnotatorClient({ credentials: visionCredentials });\n        \n        const base64PdfData = flowInput.pdfDataUri.substring(flowInput.pdfDataUri.indexOf(',') + 1);\n        \n        const request = {\n          requests: [\n            {\n              inputConfig: {\n                content: base64PdfData,\n                mimeType: 'application/pdf',\n              },\n              features: [{ type: 'DOCUMENT_TEXT_DETECTION' }],\n            },\n          ],\n        };\n\n        console.log('Sending PDF to Google Cloud Vision API for OCR...');\n        const [visionResult] = await visionClient.batchAnnotateFiles(request as any); // Cast to any to match SDK\n        const responses = visionResult.responses?.[0]?.responses;\n\n        if (!responses || responses.length === 0 || !responses[0].fullTextAnnotation) {\n          console.error('Google Cloud Vision API did not return text annotation.');\n          return { jsonOutput: defaultEmptyJsonOutputString, error: 'Google Cloud Vision OCR did not return text. The PDF might be image-only or unreadable by OCR.' };\n        }\n        \n        const ocrText = responses[0].fullTextAnnotation.text || \"\";\n        console.log('OCR Text from Vision API (first 500 chars):', ocrText.substring(0, 500));\n\n        if (!ocrText.trim()) {\n            console.warn('Vision API returned empty text from OCR.');\n            return { jsonOutput: defaultEmptyJsonOutputString, error: 'Google Cloud Vision OCR returned empty text.' };\n        }\n\n        const { output: visionStructuredData } = await structureOcrTextPrompt({ ocrText });\n        structuredData = visionStructuredData;\n\n      } else { // Default to 'genkitDirect'\n        console.log('Using Genkit Direct AI engine.');\n        const { output: genkitStructuredData } = await genkitDirectPdfProcessPrompt({ pdfDataUri: flowInput.pdfDataUri });\n        structuredData = genkitStructuredData;\n      }\n\n      if (!structuredData) {\n        const errorMessage = \"AI model did not return structured data after processing.\";\n        console.error(errorMessage, 'Input to prompt:', flowInput);\n        return { jsonOutput: defaultEmptyJsonOutputString, error: errorMessage };\n      }\n      \n      const jsonOutputString = JSON.stringify(structuredData);\n      console.log('Successfully extracted data. Stringified output (snippet):', jsonOutputString.substring(0, 250) + (jsonOutputString.length > 250 ? \"...\" : \"\"));\n      return { jsonOutput: jsonOutputString };\n\n    } catch (error: any) {\n      let errorMessage = `AI processing error: ${error.message}`;\n      if (error.response?.data?.error?.message) { // For Google API specific errors\n        errorMessage += ` Google API Error: ${error.response.data.error.message}`;\n      }\n      console.error('Error during data extraction flow:', error.message, error.stack, 'Input:', flowInput);\n      return { jsonOutput: defaultEmptyJsonOutputString, error: errorMessage };\n    }\n  }\n);\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 529, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 580, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAoR,GACjT,kDACA","debugId":null}},
    {"offset": {"line": 594, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAgQ,GAC7R,8BACA","debugId":null}},
    {"offset": {"line": 608, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}