{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 215, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/genkit.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/googleai';\n\nexport const ai = genkit({\n  plugins: [googleAI()],\n  model: 'googleai/gemini-2.0-flash',\n});\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AAAA;;;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;QAAC,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD;KAAI;IACrB,OAAO;AACT","debugId":null}},
    {"offset": {"line": 260, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/extract-data-from-pdf.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview Extracts data from a PDF using OCR (Tesseract.js) and AI (Genkit).\n *\n * - extractDataFromPdf - A function that handles the data extraction process.\n * - ExtractDataFromPdfInput - The input type for the extractDataFromPdf function.\n * - ExtractDataFromPdfOutput - The return type for the extractDataFromPdf function.\n */\n\nimport { ai } from '@/ai/genkit';\nimport {z} from 'genkit';\nimport Tesseract from 'tesseract.js';\nimport * as pdfjsLib from 'pdfjs-dist'; // Changed import\n// pdfjsLib.GlobalWorkerOptions.workerSrc = require.resolve('pdfjs-dist/build/pdf.worker.js'); // May be needed depending on environment\nimport { createCanvas } from 'canvas';\n\n// Schema for the overall flow input\nconst ExtractDataFromPdfInputSchema = z.object({ \n pdfDataUri: z.string()\n    .describe(\n      \"The PDF document, as a data URI that must include a MIME type and use Base64 encoding. Expected format: 'data:<mimetype>;base64,<encoded_data>'.\"\n    ),\n});\nexport type ExtractDataFromPdfInput = z.infer<typeof ExtractDataFromPdfInputSchema>;\n \nconst ExtractDataFromPdfOutputSchema = z.object({jsonOutput: z.string().describe('The extracted data from the PDF, as a JSON string.'),}); \nexport type ExtractDataFromPdfOutput = z.infer<typeof ExtractDataFromPdfOutputSchema>;\n\n// Schema for the Genkit prompt input (after OCR)\nconst PromptInputSchema = z.object({\n  ocrText: z.string().describe('Text extracted from the PDF document using OCR.'),\n});\n\n// Helper class for pdfjs-dist in Node.js\nclass NodeCanvasFactory {\n  create(width: number, height: number) {\n    const canvas = createCanvas(width, height);\n    const context = canvas.getContext('2d');\n    return {\n      canvas: canvas,\n      context: context,\n    };\n  }\n\n  reset(canvasAndContext: { canvas: any; context: any }, width: number, height: number) {\n    if (!canvasAndContext.canvas) {\n      // Sanity check it is really supplied.\n      throw new Error('Canvas is not specified');\n    }\n    canvasAndContext.canvas.width = width;\n    canvasAndContext.canvas.height = height;\n  }\n\n  destroy(canvasAndContext: { canvas: any; context: any }) {\n    if (!canvasAndContext.canvas) {\n      // Sanity check it is really supplied.\n      throw new Error('Canvas is not specified');\n    }\n    // Zeroing the width and height cause Firefox to release graphics\n    // resources immediately, which can greatly reduce memory consumption.\n    canvasAndContext.canvas.width = 0;\n    canvasAndContext.canvas.height = 0;\n    canvasAndContext.canvas = null;\n    canvasAndContext.context = null;\n  }\n}\n\nasync function pdfPageToImageDataUri(pdfData: Uint8Array, pageNum: number): Promise<string> {\n  const loadingTask = pdfjsLib.getDocument({ data: pdfData });\n  const pdfDocument = await loadingTask.promise;\n  if (pageNum > pdfDocument.numPages) {\n    console.warn(`Requested page ${pageNum} is out of bounds. PDF has ${pdfDocument.numPages} pages. Using last page.`);\n    pageNum = pdfDocument.numPages;\n  }\n  if (pageNum === 0 && pdfDocument.numPages > 0) {\n    pageNum = 1; // Default to first page if 0 and pages exist\n  }\n  if (pdfDocument.numPages === 0) {\n    throw new Error(\"PDF document has no pages.\");\n  }\n\n  const page = await pdfDocument.getPage(pageNum);\n  const viewport = page.getViewport({ scale: 2.0 }); // Increased scale for potentially better OCR\n\n  const canvasFactory = new NodeCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  \n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n    canvasFactory: canvasFactory,\n  };\n  \n  await page.render(renderContext).promise;\n  const imageDataUrl = canvasAndContext.canvas.toDataURL('image/png');\n  \n  page.cleanup(); \n  canvasFactory.destroy(canvasAndContext);\n\n  return imageDataUrl;\n}\n\n\nexport async function extractDataFromPdf(input: ExtractDataFromPdfInput): Promise<ExtractDataFromPdfOutput> {\n const response = await extractDataFromPdfFlow(input);\n return response;\n}\n\nconst extractDataFromPdfPromptObj = ai.definePrompt({\n  name: 'extractDataFromPdfPrompt',\n  input: { schema: PromptInputSchema }, \n  output: { schema: ExtractDataFromPdfOutputSchema },\n  prompt: `You are an expert data extraction specialist.\nYou will receive text content extracted via OCR from a PDF document. Your task is to analyze this text and extract all the relevant information from it and return it as a JSON object.\n\nThe JSON object (which will be the string value for the 'jsonOutput' key) should have the following top-level keys:\n- \\`classe\\` (string): The class concerned by the attendance sheet.\n- \\`cours\\` (string): The course concerned by the attendance sheet.\n- \\`date\\` (string): The date of the attendance sheet.\n- \\`nom_du_professeur\\` (string): The name of the professor.\n- \\`nombre_des_présents\\` (number): The total number of attendees.\n- \\`salle_n\\` (string): The room number.\n- \\`séance\\` (string): The session time.\n- \\`présences\\` (array of objects): An array representing the attendees. Each object in the array should have two keys:\n  - \\`n\\` (string): The student number.\n  - \\`nom_prénom\\` (string): The student's full name.\n\nCRITICAL INSTRUCTION FOR HANDLING MISSING DATA:\nIf any individual field specified above (e.g., \\`classe\\`, \\`cours\\`, \\`date\\`, \\`nom_du_professeur\\`, \\`salle_n\\`, \\`séance\\`) cannot be found or determined from the OCR text, you MUST include the key in the JSON output but use an empty string \\`\"\"\\` as its value.\nFor the \\`nombre_des_présents\\` field, if it cannot be determined, use the number \\`0\\`.\nFor the \\`présences\\` array, if no attendees are found or the data is missing, you MUST include the \\`présences\\` key with an empty array \\`[]\\` as its value. Within objects in the 'présences' array, if 'n' or 'nom_prénom' cannot be found, use an empty string \\`\"\"\\` for their values.\nDO NOT OMIT ANY KEYS specified in the structure. The goal is to always return a JSON string that strictly conforms to the defined structure, using empty/default values for missing information.\n\nFormat the entire JSON object (structured as described above) as a single string value for the 'jsonOutput' key. Only output the JSON object containing the 'jsonOutput' key. For example: {\"jsonOutput\": \"{\\\\\"classe\\\\\": \\\\\"...\", \\\\\"présences\\\\\": [], ...}\"}\n\nExtracted OCR Text:\n{{{ocrText}}}`,\n});\n\nconst extractDataFromPdfFlow = ai.defineFlow(\n  {\n    name: 'extractDataFromPdfFlow',\n    inputSchema: ExtractDataFromPdfInputSchema, // Flow still takes pdfDataUri\n    outputSchema: ExtractDataFromPdfOutputSchema,\n  }, \n  async (flowInput) => {\n    let ocrText = '';\n    try {\n      console.log('Starting PDF to Text conversion...');\n      const base64PdfData = flowInput.pdfDataUri.split(',')[1];\n      if (!base64PdfData) {\n        throw new Error('Invalid PDF data URI format. Missing base64 data.');\n      }\n      const pdfBuffer = Buffer.from(base64PdfData, 'base64');\n      \n      // For simplicity, processing only the first page.\n      // A more robust solution might iterate through pages or allow page selection.\n      const imageDataUri = await pdfPageToImageDataUri(new Uint8Array(pdfBuffer), 1);\n      console.log('PDF page converted to image data URI.');\n\n      console.log('Starting Tesseract OCR...');\n      const { data: { text: tesseractOutputText } } = await Tesseract.recognize(\n        imageDataUri,\n        'fra', // Using French for OCR\n        { \n          // logger: m => console.log(m) // Uncomment for detailed Tesseract progress\n        }\n      );\n      ocrText = tesseractOutputText;\n      console.log('Tesseract OCR completed. Extracted text length:', ocrText.length);\n      if (!ocrText.trim()) {\n        console.warn('Tesseract OCR returned empty or whitespace-only text.');\n      }\n\n    } catch (ocrError: any) {\n      console.error('Error during Tesseract/pdfjs OCR processing:', ocrError.message, ocrError.stack);\n      ocrText = \"\"; // Fallback to empty text if OCR fails\n      // Optionally, could return { jsonOutput: '{}' } here directly if OCR is critical and fails\n    }\n    \n    const promptInput = { ocrText };\n    console.log('Input to Genkit prompt (AI model):', { ocrTextLength: promptInput.ocrText.length }); // Log length to avoid huge text in logs\n\n    let response;\n    try {\n      response = await extractDataFromPdfPromptObj(promptInput); \n      console.log('Full response object from AI prompt:', response); \n    } catch (error: any) {\n      console.error('Error during AI model interaction:', error.message, error.stack);\n      return { jsonOutput: '{}' }; \n    }\n\n    if (!response || typeof response !== 'object' || !('jsonOutput' in response)) {\n      console.error('AI response is missing \"jsonOutput\", not an object, or null. Raw response:', response);\n      return { jsonOutput: '{}' }; \n    }\n\n    const jsonOutputValue = response.jsonOutput;\n    if (typeof jsonOutputValue !== 'string') {\n      console.error('The value of \"jsonOutput\" is not a string. Value:', jsonOutputValue);\n      return { jsonOutput: '{}' };\n    }\n\n    try {\n      JSON.parse(jsonOutputValue); // Validate the inner JSON string\n      return response; // Return { jsonOutput: \"stringified_json_data\" }\n    } catch (parseError: any) {\n      console.error('Error parsing jsonOutput string as JSON:', parseError.message, 'String value was:', jsonOutputValue);\n      return { jsonOutput: '{}' };\n    }\n  }\n);\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 478, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 529, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAoR,GACjT,kDACA","debugId":null}},
    {"offset": {"line": 543, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAgQ,GAC7R,8BACA","debugId":null}},
    {"offset": {"line": 557, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}