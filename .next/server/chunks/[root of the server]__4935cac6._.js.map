{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/schemas/pdf-data-schema.ts"],"sourcesContent":["\nimport { z } from 'zod';\n\n// Schema for the actual structured data the AI should extract\nexport const ExtractedPdfDataSchema = z.object({\n  classe: z.string().describe('The class name. Return \"\" if not found.'),\n  cours: z.string().describe('The course name. Return \"\" if not found.'),\n  date: z.string().describe('The date of the session. Return \"\" if not found.'),\n  nom_du_professeur: z.string().describe(\"The professor's name. Return \\\"\\\" if not found.\"),\n  nombre_des_présents: z.number().describe('The number of present students. Return 0 if not found.'),\n  salle_n: z.string().describe('The room number. Return \"\" if not found.'),\n  séance: z.string().describe('The session information. Return \"\" if not found.'),\n  présences: z.array(z.object({\n    n: z.string().describe('The student number or ID. Return \"\" if not found.'),\n    nom_prénom: z.string().describe(\"The student's full name. Return \\\"\\\" if not found.\"),\n  })).describe('An array representing the attendees. Return [] if not found or if data is missing for all attendees.'),\n});\nexport type ExtractedPdfData = z.infer<typeof ExtractedPdfDataSchema>;\n"],"names":[],"mappings":";;;AACA;;AAGO,MAAM,yBAAyB,sIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC7C,QAAQ,sIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC5B,OAAO,sIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC3B,MAAM,sIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC1B,mBAAmB,sIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACvC,qBAAqB,sIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACzC,SAAS,sIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC7B,QAAQ,sIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC5B,WAAW,sIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,sIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QAC1B,GAAG,sIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;QACvB,YAAY,sIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAClC,IAAI,QAAQ,CAAC;AACf","debugId":null}},
    {"offset": {"line": 92, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/api/save-to-mongodb/route.ts"],"sourcesContent":["\nimport type { NextRequest } from 'next/server';\nimport { NextResponse } from 'next/server';\nimport mongoose, { type Model } from 'mongoose';\nimport type { ExtractedPdfData } from '@/ai/schemas/pdf-data-schema';\nimport { ExtractedPdfDataSchema } from '@/ai/schemas/pdf-data-schema';\n\nconst MONGO_DATABASE_NAME = 'pdf_data_db'; // Still relevant for organizational purposes if needed\nconst MONGO_COLLECTION_NAME = 'extracted_documents'; // This will be the Mongoose model name\n\nconst MONGODB_URI = process.env.MONGODB_URI;\n\nif (!MONGODB_URI) {\n  console.error('MongoDB URI not configured in environment variables.');\n  // We cannot throw an error at the top level here as it prevents build\n  // We'll check MONGODB_URI inside the POST handler\n}\n\n// Mongoose schema definition\nconst PresenceMongooseSchema = new mongoose.Schema({\n  n: { type: String, default: \"\" },\n  nom_prénom: { type: String, default: \"\" }\n}, { _id: false }); // No separate _id for subdocuments unless needed\n\nconst ExtractedPdfDataMongooseSchema = new mongoose.Schema<ExtractedPdfData>({\n  classe: { type: String, default: \"\" },\n  cours: { type: String, default: \"\" },\n  date: { type: String, default: \"\" },\n  nom_du_professeur: { type: String, default: \"\" },\n  nombre_des_présents: { type: Number, default: 0 },\n  salle_n: { type: String, default: \"\" },\n  séance: { type: String, default: \"\" },\n  présences: [PresenceMongooseSchema]\n}, { timestamps: true }); // Add timestamps for createdAt and updatedAt\n\n// Prevent model recompilation in Next.js dev environment\nlet ExtractedDocumentModel: Model<ExtractedPdfData>;\ntry {\n  ExtractedDocumentModel = mongoose.model<ExtractedPdfData>(MONGO_COLLECTION_NAME);\n} catch (e) {\n  ExtractedDocumentModel = mongoose.model<ExtractedPdfData>(MONGO_COLLECTION_NAME, ExtractedPdfDataMongooseSchema);\n}\n\n\n// Mongoose connection helper\ninterface MongooseCache {\n  conn: typeof mongoose | null;\n  promise: Promise<typeof mongoose> | null;\n}\n\n// Extend the NodeJS.Global interface to declare the mongoose cache\ndeclare global {\n  // eslint-disable-next-line no-var\n  var mongooseCache: MongooseCache;\n}\n\nlet cached = global.mongooseCache;\n\nif (!cached) {\n  cached = global.mongooseCache = { conn: null, promise: null };\n}\n\nasync function dbConnect() {\n  if (!MONGODB_URI) {\n    throw new Error('MongoDB URI not configured. Please set MONGODB_URI in .env file.');\n  }\n  if (cached.conn) {\n    console.log('Using cached Mongoose connection');\n    return cached.conn;\n  }\n  if (!cached.promise) {\n    const opts = {\n      bufferCommands: false, // Disable command buffering\n      serverSelectionTimeoutMS: 5000, // Timeout after 5s instead of 30s\n    };\n    console.log('Creating new Mongoose connection');\n    cached.promise = mongoose.connect(MONGODB_URI, opts).then((mongooseInstance) => {\n      console.log('Mongoose connected successfully');\n      return mongooseInstance;\n    }).catch(err => {\n        console.error('Mongoose connection error during initial connect:', err);\n        cached.promise = null; // Reset promise on error\n        throw err;\n    });\n  }\n  try {\n    cached.conn = await cached.promise;\n  } catch (err) {\n    cached.promise = null; // Ensure promise is cleared on error so retries can happen\n    throw err;\n  }\n  return cached.conn;\n}\n\nexport async function POST(request: NextRequest) {\n  if (!MONGODB_URI) {\n    return NextResponse.json({\n      success: false,\n      message: 'MongoDB connection string is not configured. Please set MONGODB_URI in .env file.',\n    }, { status: 500 });\n  }\n\n  let dataToSave: ExtractedPdfData;\n  try {\n    const rawData = await request.json();\n    const validationResult = ExtractedPdfDataSchema.safeParse(rawData);\n    if (!validationResult.success) {\n      console.error('Invalid data format received:', validationResult.error.flatten());\n      return NextResponse.json({\n        success: false,\n        message: `Invalid data format: ${validationResult.error.flatten().formErrors.join(', ')}`,\n      }, { status: 400 });\n    }\n    dataToSave = validationResult.data;\n  } catch (error) {\n    console.error('Failed to parse request body:', error);\n    return NextResponse.json({ success: false, message: 'Failed to parse request body.' }, { status: 400 });\n  }\n\n  try {\n    await dbConnect();\n    console.log('Connected to MongoDB via Mongoose from API route');\n\n    const newDocument = new ExtractedDocumentModel(dataToSave);\n    const savedDocument = await newDocument.save();\n    \n    const insertedId = savedDocument._id.toString();\n\n    console.log(`Data saved to MongoDB with ID: ${insertedId} using Mongoose from API route`);\n    return NextResponse.json({\n      success: true,\n      message: 'Data successfully saved to MongoDB using Mongoose.',\n      recordId: insertedId,\n    });\n  } catch (error: any) {\n    console.error('Failed to save data to MongoDB using Mongoose from API route:', error);\n    let errorMessage = `Failed to save data to MongoDB (Mongoose): ${error.message}`;\n     if (error.name === 'MongoNetworkError' || error.message?.includes('ECONNREFUSED') || error.message?.includes('timeout')) {\n        errorMessage = `MongoDB Network Error (Mongoose): ${error.message}. Check IP Whitelisting, network connectivity, and if MongoDB server is running.`;\n    } else if (error.name === 'MongooseServerSelectionError') {\n         errorMessage = `MongoDB Server Selection Error (Mongoose): ${error.message}. Could not connect to any server in your MongoDB cluster. Verify connection string and server status.`;\n    } else if (error.message && (error.message.includes('SSL') || error.message.includes('TLS'))) {\n        errorMessage = `MongoDB SSL/TLS Error (Mongoose): ${error.message}. Ensure your environment supports the required TLS version/ciphers for Atlas.`;\n    }\n    return NextResponse.json({\n      success: false,\n      message: errorMessage,\n    }, { status: 500 });\n  }\n  // Mongoose handles connection closing implicitly or keeps it open for reuse.\n  // No explicit client.close() needed here like with the native driver in serverless contexts.\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}